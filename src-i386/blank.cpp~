//#include <stdio.h>
//#include <math.h>
//#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <ctime>
#include <cmath>
//#include <gsl/gsl_rng.h>
//#include <gsl/gsl_randist.h>
#include <R.h>
#include <Rmath.h>
#include "mmsbm.h"
//using namespace std;
using std::ifstream;
//using std::ofstream;

//gsl_rng *rng;
//ofstream myfile;


extern "C" {
  
  
  // Function to be called by R
  void sbm(int *iters, int *nn_t, int *kk_t, int *YY,
	   double *betaPrior, double *eta,
	   double *flatTable, int *burn_t, int *thin_t,
	   int *start_t, int *multi_t,double *logLik)
  {
    
    GetRNGstate();

    
    int start = *start_t, multiImpute = *multi_t;
    int nn = *nn_t, dd = *kk_t;
    //    double BB[dd*dd], PP[nn*dd];
    //    int yyComplete[nn*nn], PPint[nn];
    

    /*****  INITIALIZATION  *****/
    //  Initializing SBM object
    sbm_t mySBM (*nn_t, *kk_t, YY, betaPrior, eta, *multi_t);
    //  If start is positive, load initial values
    if(start > 0){
      mySBM.loadTable(start,flatTable);
    }
    mySBM.print(0 == 1);
    

    int total = *iters, burnIn = *burn_t, thin = *thin_t;
    int ii, converged;
    double qq = 3.2;
    int shift_size = 100, extend_max = 10, extend_count = 0;
    
    //    sbmMCMC(total, burnIn, thin, YY, nn, dd, eta, betaPrior, logLik,
    //	    BB, PP, PPint, yyComplete, flatTable, start, multiImpute);
    
    //  MCMC Loop
    converged = 0;
    while((converged != 1) & (extend_count <= extend_max)){
      for(ii = start ; ii < total ; ii++){
	if(multiImpute == 1){
	  //sbmImputeMissingValues(nn,dd,YY,yyComplete,BB,PP,PPint);
	  mySBM.imputeMissingValues();
	}
	//	sbmStep(yyComplete, nn, dd, eta, betaPrior, BB, PP,PPint);
	mySBM.step();
	//sbmRotate(nn,dd,BB,PP,PPint);
	mySBM.rotate();
	
	if(ii >= burnIn && ((ii - burnIn) % thin == 0)){
	  logLik[(ii - burnIn)/thin] = mySBM.LL();
	  //sbmLogLikYY(nn,dd,YY,BB,PP,PPint);
	  mySBM.updateFlatTable((ii - burnIn)/thin,flatTable);
	  //updateFlatTable((ii - burnIn)/thin, nn, dd, BB, PP, flatTable);
	}//    printTableMMSBM(nn, dd, BB, PP, sendMat, recMat);
      }
      //Rprintf("total = %d\n",total);
      converged = convergenceCheck(logLik,(total - burnIn)/thin,qq);
      Rprintf("Converged Status %d, after %d extensions\n",converged,extend_count);
      if(converged != 1){
	extend_count = extend_count + 1;
	shiftFlatTable(shift_size,nn,dd,(total - burnIn)/thin,flatTable);
	start = total - (shift_size*thin);
      }
    }
    if(converged != 1){
      Rprintf("MCMC Failed to Converge\n");
    }
    
    
    PutRNGstate();
    
  }
  
  //  Function to be called by R
  void mmsbm(int *iters, int *nn_t, int *kk_t, int *YY,
	     double *betaPrior, double *alpha,
	     double *flatTable, int *burn_t, int *thin_t,
	     int *start_t,int *multi_t)
  {
    
    /* Initializing Random Number Generator */
    //  time_t seed = time(NULL);
    //  rng = gsl_rng_alloc(gsl_rng_mt19937); /* start the RNG */
    //  gsl_rng_set(rng, static_cast<unsigned long int>(seed));
    GetRNGstate();
   
    //  Reading in values from pointers
    int total = *iters;
    int burnIn = *burn_t, thin = *thin_t;
    int start = *start_t, multiImpute = *multi_t;
    int dd = *kk_t, nn = *nn_t;
    
    //  Allocating memory for variables
    int yyComplete[nn*nn];
    double BB[dd*dd];
    double PP[nn*dd];
    int sendMat[nn*nn]; int recMat[nn*nn];
    
    //  Performing MCMC Algorithm
    mmsbmMCMC(total,burnIn,thin,YY,nn,dd,alpha,betaPrior,
	      BB,PP,sendMat,recMat,yyComplete,
	      flatTable,start,multiImpute);
    
    //  Sending RNG state back to R
    PutRNGstate();
  }
}


/********************************************
 **********  Output Functions  **************
 *******************************************/

/*  These functions allow easy printing of 
 *  matrix-like objects, given the number of
 *  rows and columns.
 */

void RprintDoubleMat(int rows, int cols, double *mat){
  int ii, jj;
  for(ii = 0 ; ii < rows ; ii++){
    for(jj = 0 ; jj < cols ; jj++){
      Rprintf("%.3f ",mat[ii*cols + jj]);
    }
    Rprintf("\n");
  }
}
  
void RprintIntMat(int rows, int cols, int *mat){
  int ii, jj;
  for(ii = 0 ; ii < rows ; ii++){
    for(jj = 0 ; jj < cols ; jj++){
      Rprintf("%d ",mat[ii*cols + jj]);
    }
    Rprintf("\n");
  }
}
  

/*
//  Prints all of the matrices involved in an MMSBM step
void printMMSBM(int nn, int dd, double *BB, double *PP,
int *sendMat, int *recMat){
    
printf("\nBlock Matrix\n");
printDoubleMat(dd,dd,BB);
    
printf("\nPP Matrix\n");
printDoubleMat(nn,dd,PP);
    
printf("\nSender Matrix:\n");
printIntMat(nn,nn,sendMat);
    
printf("Receiver Matrix:\n");
printIntMat(nn,nn,recMat);
    
}
*/
/*
  void printTableMMSBM(int nn, int dd, double *BB, double *PP,
  int *sendMat, int *recMat){
  int ii;
  for(ii = 0 ; ii < dd*dd ; ii++){
  //    printf("%f\t",BB[ii]);
  myfile << BB[ii] << "\t";
  }
  for(ii = 0 ; ii < nn*dd ; ii++){
  //    printf("%f\t",PP[ii]);
  myfile << PP[ii] << "\t";
  }
  myfile << "\n";
  }
*/
  
//  Saves the current MMSBM state to the flatTable
void rdirichlet(int k, double *alpha, double *x){
  int ii;
  double draw[k];
  double total = 0.0;
    
  for(ii=0 ; ii < k ; ii++){
    draw[ii] = rgamma(alpha[ii],1);
    //draw[ii] = gsl_ran_gamma(rng,alpha[ii],1);
    total = total + draw[ii];
  }
    
  for(ii = 0; ii < k; ii++){
    x[ii] = draw[ii] / total;
  }
}
  
  
void updateFlatTable(int iter, int nn, int dd, double *BB, double *PP, 
		     double *flatTable){
  int ii, offset;
  offset = iter * (dd * (nn + dd));
  for(ii = 0 ; ii < dd*dd ; ii++){
    flatTable[offset + ii] = BB[ii];
  }
  offset = offset + dd*dd;
  for(ii = 0 ; ii < nn*dd ; ii++){
    flatTable[offset + ii] = PP[ii];
  }
    
}

void shiftFlatTable(int shift_size, int nn, int dd, int total,
		    double *flatTable){
  int ii;
  int flatTotal = total * (dd * (nn + dd));
  int flatShift = shift_size * (dd *(nn + dd));
  for(ii = 0 ; ii < flatTotal - flatShift ; ii++){
    flatTable[ii] = flatTable[ii + flatShift];
  }
    
}



void getMeanVar(double *vec, int lower, int upper,
		double *Mean_t, double *Var_t, double * Len_t){

    
  double Var;
  double Mean = 0.0;
  double Len = upper - lower;
  double SumSq = 0.0;
  int ii;
  for(ii = lower ; ii < upper ; ii++){
    Mean = Mean + vec[ii];
    SumSq = SumSq + vec[ii] * vec[ii];
  }
  Mean = Mean / Len;
  Var = ((SumSq/Len) - (Mean * Mean))*(Len / (Len-1));
  *Mean_t = Mean;
  *Var_t = Var;
  *Len_t = Len;
    
}
  
int convergenceCheck(double *logLik, int total, double qq){
    
  double llMean1, llVar1, llLen1;
  double llMean2, llVar2, llLen2;
  double sdTot;
    
    
  //Rprintf("lower1 = %d, upper1 = %d\n",0,total/10);
  getMeanVar(logLik,0,total/10,
	     &llMean1, &llVar1, & llLen1);
  //Rprintf("lower2 = %d, upper2 = %d\n",total/2,total);    
  getMeanVar(logLik,total/2,total,
	     &llMean2, &llVar2, & llLen2);
  sdTot = sqrt((llVar1/llLen1) + (llVar2/llLen2));
    
  //Rprintf("Mean 1 = %f \t Mean 2 = %f \t sd.est = %f\n",
  //llMean1,llMean2,sdTot);
    

  if((llMean2 - llMean1) <= (qq * sdTot)){
    if((llMean1 - llMean2) <= (qq * sdTot)){
      return(1);
    }
  }
  return(0);
      
}



/////////////  UNUSED OLD FUNCTIONS  /////////////////

/*
  int *readCSV(const char *file, int *rows, int *cols){
  ifstream in;
  in.open(file);

  in >> *rows >> *cols;
  //  printf("Rows: %d  Columns: %d\n",*rows, *cols);
  int *table;
  int total = ( *rows) * ( *cols);
  table = new int [total];
  int ii;
  for(ii = 0 ; ii < total ; ii++){
  in >> table[ii];
  }
  in.close();  
  return(table);
  }
*/



